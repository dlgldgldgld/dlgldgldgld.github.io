---
layout: single
title:  "[Kafka] - 04. 카프카 컨슈머"
category: Kafka
tag: Kafka
---

컨슈머는 프로듀서로부터 카프카에 전달된 메시지를 가져오는 역할을 합니다.  
카프카에 토픽-파티션 단위로 저장된 메시지를 정확하게 가져오는 것이 중요한 핵심 사항 중 하나입니다.

이번 장에서는 컨슈머가 어떤방식으로 동작하는 지에 대해 살펴보도록 하겠습니다.

# 컨슈머 오프셋 관리
- 컨슈머의 동작 중 가장 핵심은 오프셋 관리라고 할 수 있음.
- 카프카는 항상 node의 장애를 염두하여 설계됟 프로그램이기 때문에 복구가 매우 중요함.
- 장애 발생시 기존 컨슈머의 역할을 대신할 경우를 위하여 message의 위치를 나타내는 offset이 존재.
- consumer는 그룹별로 offset을 저장하며 이에 관한 정보는 `__consumer_offsets` 토픽에 기록 됨.

## Consumer offset 관련 기본 동작

![alt](../../assets/images/2022-04-11-kafka-consumer/image_1.png)  

1. 2번 Offset 메시지 C까지 read.
2. 그 다음으로 읽어야 할 3번 Offset의 위치를 `__consumer_ofsets` 토픽에 저장.

## consumer offset 관련 properties setting 
- offsets.topic.num.partitions : default 50
- offsets.topic.replication.factor : default 3

# 그룹 코디네이터
- 컨슈머 그룹 내의 각 컨슈머들은 서로 자신의 정보를 공유하면서 하나의 공동체로 동작.
- 컨슈머 그룹 내의 컨슈머들은 언제든지 자신이 속한 컨슈머 그룹에서 떠나거나 합류하는 것이 가능.
- 컨슈머 그룹에서 각 컨슈머들에게 작업을 균등하게 분해하는 동작을 **컨슈머 리밸런싱**이라고 함.
- 이를 컨트롤하기 위해 그룹마다 코디네이터가 하나씩 존재하는데 이를 **그룹 코디네이터** 부름.
- **그룹 코디네이터**의 목적은 컨슈머 그룹이 구독한 토픽의 파티션들과 그룹의 멤버들을 트래킹 하는것.
- 따라서 파티션 또는 그룹의 멤버에 변화가 생기면, 작업을 균등하게 재분배하기 위해 컨슈머 리밸런싱 동작이 발생.
- 이러한 그룹 코디네이터는 브로커 중 하나에 위치하게 됨.

![alt](../../assets/images/2022-04-11-kafka-consumer/image_2.png)  

## 컨슈머 그룹과 그룹 코디네이터의 동작 과정

![alt](../../assets/images/2022-04-11-kafka-consumer/image_3.png)  
[컨슈머 그룹과 그룹 코디네이터간의 동작 이미지]

1. 컨슈머는 컨슈머 설정값 중에서 bootstrap.brokers 리스트에 있는 브로커에게 컨슈머 클라이언트와 초기 커넥션을 연결하기 위한 요청을 보냄.
2. 요청을 받은 브로커는 그룹 코디네이터를 생성, 컨슈머에게 응답을 보냄. 컨슈머 그룹의 첫번째 컨슈머가 등록될때까지 아무 작업도 일어나지 않음.
3. 그룹 코디네이터는 group.initial.rebalance.delay.ms의 시간동안 컨슈머의 요청을 기다림
4. **컨슈머는 컨슈머 등록 요청을 그룹 코디네이터에게 보냄. 이때 가장 먼저 요청을 보내는 컨슈머가 컨슈머 그룹의 리더가 됨.**
5. 컨슈머 등록 요청을 받은 그룹 코디네이터는 **해당 컨슈머 그룹이 구독하는 토픽 파티션 리스트 등 리더 컨슈머의 요청에 응답을 보냄.**
6. 리더 컨슈머는 정해진 컨슈머 파티션 할당 전략에 따라 그룹내 컨슈머들에게 파티션을 할당한 뒤 그룹 코디네이터에게 전달.
7. 그룹 코디네이터는 해당 정보를 캐시하고 각 그룹 내 컨슈머들에게 성공을 알림
8. 각 컨슈머들은 각자 지정된 토픽 파티션으로부터 메시지들을 가져옴.

위와 같이 실제로 컨슈머 그룹은 그룹 코디네이터와 서로 긴밀하게 메시지를 주고받으며 안정적인 관리를 할 수 있도록 노력하는 것을 알 수 있습니다.

## 컨슈머 하트비트(heart beat)
- 컨슈머들은 현재 자신들이 속한 컨슈머 그룹을 leave 할수도, 새롭게 join 할수도 있음.
- 이러한 컨슈머 그룹의 변화들은 컨슈머 코디네이터에게 컨슈머가 join 혹은 leave 요청을 보냄으로써 자연스럽게 처리함.
- 하지만 <u>컨슈머가 장애로 leave 요청을 보내지 못할 경우,</u> 이를 감지할 수 있어야 하는데 이 때 사용되는 것이 **하트비트(heart beat)**임.

| consumer 옵션         | default 값 | 설명                                                                                                                                                                              |
| --------------------- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| heartbeat.interval.ms | 3000       | 그룹 코디네이터와 하트비트 인터벌 시간. 해당 시간은 session.timeout.ms보다 낮게 설정해야하며 1/3 수준이 적절.                                                                     |
| session.timeout.ms    | 10000      | 어떤 컨슈머가 특정 시간 안에 하트비트를 받지 못하면 문제가 발생했다고 판단해 컨슈머 그룹에서 해당 컨슈머는 제거되고 리밸런싱 동작이 발생.                                         |
| max.poll.interval.ms  | 300000     | 컨슈머는 주기적으로 poll()을 호출해 토픽으로부터 레코드들을 가져오는데, poll() 호출 후 최대 5분간 poll() 호출이 없다면 컨슈머가 문제가 있는 것으로 판단해 리밸런싱 동작이 일어남. |

# 스태틱 멤버십
때로는 h/w 점검이나 sw update 등의 이유로 관리자는 컨슈머 그룹 내의 컨슈머들을 하나씩 순차적으로 재시작하고 싶은 경우가 있습니다. 하지만 위와 같이 하트비트를 설정할 경우 consumer의 down으로 리밸런싱이 발생하게 되고, 리밸런싱 중에는 컨슈머들이 일시 중지 되기 때문에 번거로운 상황이 올수도 있습니다.

대용량 메시지들을 처리하는 컨슈머 그룹이라면 리밸런싱 동작으로 인해 원래 상태를 복구하는데 상당한 시간이 소요될 수 있습니다.

때문에 이런 불필요한 리밸런싱을 방어하기 위해 v2.3부터 스태틱 맴버쉽(static membership)이라는 개념을 도입하게 됩니다.  
이것으로 인해 컨슈머가 재시작되더라도 리밸런싱이 발생되지 않게 됩니다.

## 스태틱 멤버십의 이점들
1. 기본적으로는 컨슈머 그룹에서 컨슈머가 떠날 때 리밸런싱이 일어나는데, 스태틱 맴버십이 적용된 컨슈머는 그룹에서 떠날 떄 그룹 코디네이터에게 알리지 않으므로 여기서 한번의 리밸런싱을 피할 수 있음.
2. 해당 컨슈머가 다시 합류할 때 그룹 코디네이터가 컨슈머의 ID를 확인하고 리밸런싱이 일어나는데, 이때도 기존 구성원임을 인지하므로 리밸런싱은 발생하지 않음.

## 적용시 유의사항
- session.timeout.ms를 기본값보다는 큰 값으로 조정해야 함. 그렇지 않을시 하트비트를 받지 못하여 강제로 리밸런싱이 발생.
- 만약 컨슈머가 재시작 시간이 총 2분 소요된다면, session.timeout.ms의 값을 2분 이상으로 설정해야함.

# 컨슈머 파티션 할당 전략